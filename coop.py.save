"""
Coop

A simple yet complete program to manage and monitor your coop.

Configuration is done in the config.ini file.
Logging is done to the file specified in this config.ini file

"""

#TODO: Make 'door' run at every whole minute with something like 'if secondold is > second then do this ... secondold = second'.
#TODO: Make 'door' the main script
#TODO: Implement early-open time
#TODO: Put motor in one definition with variables
#TODO: Put status(led) in one definition with variables

import logging
import configparser
from datetime import datetime, timezone, timedelta
import RPi.GPIO as GPIO
import time
from suntime import Sun
import threading
import urllib.request
import pytz

# config
config = configparser.ConfigParser()
config.read('/home/pi/coop/coop.ini')

# logging
logging.basicConfig(filename=config['Settings']['LogFile'], level=config['Settings']['LogLevel'],
                    format='%(asctime)s - %(levelname)s: %(message)s')

# Suntime
sun = Sun(float(config['Location']['Latitude']), float(config['Location']['Longitude']))
tz = pytz.timezone('Europe/Amsterdam')
#now = (datetime.now(timezone.utc))
offsetclose = int(config['Door']['OffsetClose'])
offsetopen = int(config['Door']['OffsetOpen'])
#opentime = sun.get_sunrise_time() - timedelta(minutes=offsetopen)
#closetime = sun.get_sunset_time() + timedelta(minutes=offset)
#opentimetomorrow = sun.get_local_sunrise_time(datetime.now() + timedelta(days=1) - timedelta(minutes=offset))
#closetimeyesterday = sun.get_local_sunset_time(datetime.now() + timedelta(days=-1)) + timedelta(minutes=offset)
global stop_threads

# GPIO
GPIO.setmode(GPIO.BOARD)
GPIO.setwarnings(False)
MotorUp = int(config['GPIO']['ActUp'])
GPIO.setup(MotorUp, GPIO.OUT)
MotorDown = int(config['GPIO']['ActDwn'])
GPIO.setup(MotorDown, GPIO.OUT)
Relais = int(config['GPIO']['Relais'])
GPIO.setup(Relais, GPIO.OUT)
SwitchDown = int(config['GPIO']['BttnDwn'])
GPIO.setup(SwitchDown, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
SwitchUp = int(config['GPIO']['BttnUp'])
GPIO.setup(SwitchUp, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)

def my_callback(channel):
    if GPIO.input(channel):     # if port 25 == 1
        logging.debug( "Rising edge detected on %s", channel  )
    else:                  # if port 25 != 1
        logging.debug( "Falling edge detected on %s", channel  )

def motor_up():
    GPIO.output(MotorUp, GPIO.HIGH)
    GPIO.output(MotorDown, GPIO.LOW)

def motor_down():
    GPIO.output(MotorDown, GPIO.HIGH)
    GPIO.output(MotorUp, GPIO.LOW)

def motor_stop():
    GPIO.output(MotorUp, GPIO.LOW)
    GPIO.output(MotorDown, GPIO.LOW)

def door():
    global door
    now = (datetime.now(timezone.utc))
    logging.debug("Time is: %s", now)
    logging.debug("Sunrise time today: %s", sun.get_sunrise_time())
    logging.debug("Sunset time today: %s", sun.get_sunset_time())
    logging.debug("MinOpen time: %s", minopenutc)
    GPIO.add_event_detect(SwitchDown,GPIO.RISING,callback=my_callback, bouncetime=200)
    GPIO.add_event_detect(SwitchUp,GPIO.RISING,callback=my_callback, bouncetime=200)
    while True:
        opentime = minopen if minopen > sun.get_sunrise_time() + timedelta(minutes=offsetopen) else sun.get_sunrise_time() + timedelta(minutes=offsetopen)
#        if sun.get_local_sunrise_time() + timedelta(minutes=offsetopen) < minopen: opentime = minopen else: opentime = sun.get_local_sunrise_time() + timedelta(minutes=offsetopen)
        closetime = sun.get_sunset_time() + timedelta(minutes=offsetclose)
        opentimetomorrow = sun.get_sunrise_time(datetime.now() + timedelta(days=1)) + timedelta(minutes=offsetopen)
        closetimeyesterday = sun.get_sunset_time(datetime.now() + timedelta(days=-1)) + timedelta(minutes=offsetclose)
        closetimetomorrow = sun.get_sunset_time(datetime.now() + timedelta(days=+1)) + timedelta(minutes=offsetclose)
        now = (datetime.now(tz=tz))
        next_open = opentime if now < opentime else opentimetomorrow
        next_close = closetime if now < closetime else closetimetomorrow
        if GPIO.input(SwitchUp) == True:
            motor_up()
            if door != "open":
                door = "open"
                logging.warning("Door status changed manually: %s", door)
        elif GPIO.input(SwitchDown) == True:
            motor_down()
            if door != "closed":
                door = "closed"
                logging.warning("Door status changed manually: %s", door)
        elif opentime < now < closetime:
            motor_up()
            if door != "open":
                door = "open"
                logging.info("Door status changed: %s", door)
                logging.info("Closing scheduled at %s", next_close)
        elif closetimeyesterday < now < opentime or closetime < now < opentimetomorrow:
            motor_down()
            if door != "closed":
                door = "closed"
                logging.info("Door status changed: %s", door)
                logging.info("Opening scheduled at %s", next_open)

def main_loop():
    while True:
        door()

if __name__ == "__main__":
    try:
        door()
    except RuntimeError as error:
        print(error.args[0])
    except KeyboardInterrupt:
        print("\nExiting application\n")
        # exit the applications
        GPIO.cleanup()
